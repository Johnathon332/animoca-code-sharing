# Installation
1. Run pnpm install to install all dependencies
2. Run docker compose up -d in the terminal within the root of the folder, this will start up the database
3. Run pnpm drizzle-kit generate:pg, this will setup the database.  Once you run the application the database schema should be setup in the db (not the best way to do this, we probably want full control on what databases changes there are, we want to be able to check the sql before deploying to db).
3. Run pnpm start in the terminal to start the application.

# Endpoints
NOTE: If I had more time I would have produced a openAPI doc for easier testing.

For the current solution there are 4 endpoints

1. POST /api/v1/auth/register - public
  - Body
  ```
    {
      email: string,
      password: string
    }
  ```

  - Returns
  ```
  {
    access_token: string
  }
  ```
2. POST /api/v1/auth/login - public
  - Body:
  ```
    {
      email: string,
      password: string
    }
  ```

  - Returns
  ```
  {
    access_token: string
  }
  ```
3. POST /api/v1/invites/redeem - protected
  - Body
  ```
  {
    code: string
  }
  ```

  - Return
  ```
  {
    success: boolean,
    message: string
  }
  ```
4. GET /api/v1/users - protected

  - return
  ```
  {
      "id": 4,
      "email": "john@gmail.com",
      "codes": [
          {
              "id": 3,
              "code": "PXkWBtE"
          }
      ],
      "referrer": {
          "code": "j8kVGiZ",
          "email": "john2@gmail.com"
      }
  }
  ```

NOTE: For protected routes you will need to take the access_token and set the Authorization header of each request


# Design
The solutions requires the user to register in order to create an account, this way we can ensure that any claim is tied to a user email.  When registering we do not allow for duplicate email addresses, there is a unique constraint on the email
I first started building out the database schema design to accomodate that a user could have multiple codes to share, this is the reason for the usersToInvites table

```
export const usersToInvites = pgTable('user_invite', {
  id: serial('id').primaryKey(),
  belongsToUserId: integer('belongs_to_user_id').notNull(),
  inviteId: integer('invite_id').references(() => invites.id).notNull(),
  claimedById: integer('claimed_by_id').references(() => users.id)
});
```

1. invite codes needs to be have a limit on usage (once or multiple times) 

I decided to generate multiple codes for a user instead of having one code claimed N times, we would need to start keeping a count in the DB of how many times it has been claimed which would lead to a race condition e.g. a person could read the count but it updates the next second therefore becoming stale data.  This could potentially be solved using a queue.  If more codes need to be generated I have left a comment in the createCodes function,  you would probably need to also create a script to add extra codes to their account.

2. invite codes should be hard to guess, but also not too hard to type
Invite codes are generated by having a string of characters from [a-zA-Z0-9] and using a random number generator for the lengh of the code.
Check createCodes function in invite.service.ts

3. invite codes are associated with a unique email address - each email can only use one invite code.
I have put checks in the redeem section to check if the user id exists in the claimByUserId column.  If it exists then they have already claimed one invite code.

4. invite codes should be trackable, admin should be able to know who the referrer is
I have a claimedBy column in the user_invite table, the user can join on to this table, and get the belongsToUserId column to find out who the code belongs to, and vice versa a person can find out who has claimed their codes.

5. design should be able to withstand high traffic and concurrency
The main bottlneck should be network lookup to the database.  Currently for every code that I generate I do a lookup into the database to see if it exists.  I think we could potentially store all these codes in a in memory store, like redis.  For now What I have done is index the code column in the invite table.  If the application itself is under load then either we need to look at switching to a microservice architecture or we put a load balancer in front of the application.

6. design should be hard to hack
Almost all routes are protected with the exception of the login and register, passwords are hashed before they are entered into the database.  Normally I would not return the access token in the body but set it as a httpOnly cookie, javascript cannot access these cookies so if there was a cross site scripting attack they wouldnt be able to get to it, whereas if it was within localstorage it would be vulnerable.


# Testing

I did most of the testing in POSTMAN, I have exported teh postman collection json in the file Animoca.postman_collection.json

1. Register for 3 accounts, this will generate one code for each person
2. I will then login with account 1, get the access_token and redeem from account 2's code
3. I will then try to claim again to make sure I cannot claim
4. Take account 3 code and claim with the same account to make sure you cannot claim if you already claimed
5. and also tested that you cannot claim your own code as well.
6. Tested getProfile this shows the user what code was claimed and the referrer, also your own claim code.

# Improvements

1.  Would have liked to dockerise the application as well so it would have an easier setup for the user.
2.  Would have liked to add automated tests for better test coverage i.e. unit tests and e2e testing.
3.  Better error handling, I have written a global custom exception handler, however I think this can be improved as there is currently a bug for the internal error messages, I assuming that all errors will be JSON objects which this is not the case. For exceptions I have 2 different messages, one for internal use and the other is for the UI.  The internal one can be used to be fed into something like an ELK stack for error / log traceabaility.  All exceptions will also have a code generated for it so if it is fed into a log tracker then it should be easy to search for.
4. Added roles based authorisation such as admin and normal user.  Admins will be able to search through all users and find out who their referrers are etc.  Where as normal users can only see details of their own account. https://docs.nestjs.com/security/authorization
5.  GetProfile wasn't really done efficiently, The drizzle ORM documentation around relations is not fully documented or at least not documented properly. The belongsTo gave me the wrong result which is the reason I did it the way I have now.
6. Load testing since one of the requirements was high traffic and concurrency.
7. Rate limiting, to stop DDOS attacks.

